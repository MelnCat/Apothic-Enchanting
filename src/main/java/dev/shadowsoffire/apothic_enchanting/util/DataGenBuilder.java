package dev.shadowsoffire.apothic_enchanting.util;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.function.BiFunction;

import net.minecraft.core.HolderLookup;
import net.minecraft.core.Registry;
import net.minecraft.core.RegistrySetBuilder;
import net.minecraft.core.RegistrySetBuilder.RegistryBootstrap;
import net.minecraft.data.DataGenerator;
import net.minecraft.data.DataProvider;
import net.minecraft.data.PackOutput;
import net.minecraft.resources.ResourceKey;
import net.neoforged.neoforge.common.conditions.ICondition;
import net.neoforged.neoforge.common.data.DatapackBuiltinEntriesProvider;
import net.neoforged.neoforge.common.data.ExistingFileHelper;
import net.neoforged.neoforge.data.event.GatherDataEvent;

/**
 * Builder to help adding multiple {@link RegistryBootstrap}s and {@link DataProvider}s to the {@link GatherDataEvent}.
 * <p>
 * Handles creation of the {@link DatapackBuiltinEntriesProvider} and passing the correct {@link HolderLookup.Provider} to the data providers.
 */
public class DataGenBuilder {

    protected final Set<String> registrySetModids;
    protected final RegistrySetBuilder registrySet = new RegistrySetBuilder();
    protected final List<DataProviderFactory<?>> providers = new ArrayList<>();
    protected final Map<ResourceKey<?>, List<ICondition>> conditions = new IdentityHashMap<>();

    /**
     * Creates a new {@link DataGenBuilder}.
     * 
     * @param modids A set of modids to generate data registry objects for.
     */
    public static DataGenBuilder create(String... modids) {
        return new DataGenBuilder(modids);
    }

    protected DataGenBuilder(String... modids) {
        this.registrySetModids = Set.of(modids);
    }

    /**
     * Adds a {@link RegistryBootstrap} to the builder. Only objects in namespaces passed to {@link #create(String...)} will be generated.
     * 
     * @param <R> The registry type of the bootstrap being added.
     * @param key The registry key for the entries being added.
     * @return this
     */
    public <R> DataGenBuilder registry(ResourceKey<? extends Registry<R>> key, RegistrySetBuilder.RegistryBootstrap<R> bootstrap) {
        this.registrySet.add(key, bootstrap);
        return this;
    }

    /**
     * Adds one or more conditions to a single registry entry held by this builder.
     * <p>
     * This method does not overwrite existing conditions, but will append this list to any existing ones for the same entry.
     * 
     * @param key        The target registry entry
     * @param conditions The list of conditions to apply. Earlier conditions will be evaluated first.
     * @return
     */
    public DataGenBuilder conditions(ResourceKey<?> key, List<ICondition> conditions) {
        List<ICondition> existing = this.conditions.computeIfAbsent(key, k -> new ArrayList<>());
        existing.addAll(conditions);
        return this;
    }

    /**
     * Vararg overload of {@link #conditions(ResourceKey, List)}
     */
    public DataGenBuilder conditions(ResourceKey<?> key, ICondition... conditions) {
        return conditions(key, Arrays.asList(conditions));
    }

    /**
     * Map overload of {@link #conditions(ResourceKey, List)} which allows providing conditions for many entries at once.
     */
    public DataGenBuilder conditions(Map<ResourceKey<?>, List<ICondition>> conditions) {
        for (Map.Entry<ResourceKey<?>, List<ICondition>> entry : conditions.entrySet()) {
            this.conditions(entry.getKey(), entry.getValue());
        }
        return this;
    }

    /**
     * Adds a single {@link DataProvider} to this builder. The provider will be given context
     * of all data registry entries generated by {@link #registry(ResourceKey, RegistryBootstrap)}.
     * 
     * @param factory A data provider factory used to create the provider.
     * @return this
     */
    public <T extends DataProvider> DataGenBuilder provider(DataProviderFactory<T> factory) {
        this.providers.add(factory);
        return this;
    }

    /**
     * Overload of {@link #provider(DataProviderFactory)} which accepts a factory that does not need the {@link ExistingFileHelper}.
     */
    public <T extends DataProvider> DataGenBuilder provider(BiFunction<PackOutput, CompletableFuture<HolderLookup.Provider>, T> factory) {
        return this.provider((output, registries, fileHelper) -> factory.apply(output, registries));
    }

    /**
     * Overload of {@link #provider(DataProviderFactory)} which accepts a factory that only needs the {@link PackOutput}.
     */
    public <T extends DataProvider> DataGenBuilder provider(DataProvider.Factory<T> factory) {
        return this.provider((output, registries, fileHelper) -> factory.create(output));
    }

    /**
     * Builds the resulting data providers and registers them to the {@link GatherDataEvent}.
     */
    public void build(GatherDataEvent event) {
        this.registerDataProviders(event);
    }

    protected void registerDataProviders(GatherDataEvent event) {
        PackOutput output = event.getGenerator().getPackOutput();

        DatapackBuiltinEntriesProvider datapackProvider = new DatapackBuiltinEntriesProvider(output, event.getLookupProvider(), this.registrySet, this.conditions, this.registrySetModids);
        CompletableFuture<HolderLookup.Provider> registries = datapackProvider.getRegistryProvider();

        DataGenerator generator = event.getGenerator();
        generator.addProvider(true, datapackProvider);
        for (DataProviderFactory<?> factory : this.providers) {
            generator.addProvider(true, factory.create(output, registries, event.getExistingFileHelper()));
        }
    }

    @FunctionalInterface
    public static interface DataProviderFactory<T extends DataProvider> {
        T create(PackOutput output, CompletableFuture<HolderLookup.Provider> registries, ExistingFileHelper fileHelper);
    }

}
